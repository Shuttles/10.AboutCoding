## 核心已转储：

​	1.非法访问（数组越界） 

​	2.表示不下(爆了)

#### 真实例子：

欧拉第21题（求因子和）

1. （21.0）首先O(nsqrt(n))的做法没有问题，但比较low。

2. （21.2）考虑O(n)做法也就是用线性筛框架去改写,but考虑到调用pow函数也需要时间，所以此法也不为上策。

3. （21.3）用cnt[max_n + 5]；来存最小素因子的幂次就可以不调用pow函数，but,报错！！核心已转储！！！

   首先通过打印中间数据发现核心代码部分不能先除后乘（因为/代表整除，可能会出现0），但是为什么会核心已转储呢?

   又通过打印数据发现因为此题要求的是真因子和，所以前面要用for循环把每个数字的因子和减去本身，而此前得到0再减本身就是负值，所以访问越界！！

4. 那么问题又来了，为什么我第二天写的代码（几乎和21.3一样）完全不会出现这种情况呢？

   通过搜索引擎发现，C/C++中数组下标可以是负数！！只要在内存范围内就可以！！！

   而我第二天写的代码中，sum数组开在cnt数组和prime数组的后面，C/C++中内存是连续分配的，所以数组下标为负值时指向的内存空间是存在的。。所以不算越界。。。不会报核心已转储！！！！（==这个bug找了一下午QAQ==）

## runtime error:

1. 超时（死循环）
2. 除以0的情况 
3.  数组越界 
4. 指针越界
5. 使用已经释放的空间
6. 数组开得太大，超出了栈的范围，造成栈溢出